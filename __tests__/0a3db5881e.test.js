// ********RoostGPT********
/*
Test generated by RoostGPT for test NodeTest using AI Type Open AI and AI Model gpt-4

ROOST_METHOD_HASH=6c862e09d7
ROOST_METHOD_SIG_HASH=0a3db5881e


*/

// ********RoostGPT********
const fs = require('fs');
const path = require('path');
const pump = require('pump');
const Telegram = require('./telegram');

jest.mock('fs');
jest.mock('pump');

describe('Telegram', () => {
  let telegram;

  beforeEach(() => {
    telegram = new Telegram();
  });

  describe('downloadFile', () => {
    it('should resolve with file path if file download is successful', () => {
      const fileId = '123';
      const downloadDir = '/downloads';
      const fileName = 'file.jpg';
      const filePath = path.join(downloadDir, fileName);
      const fileStream = {
        on: jest.fn((event, callback) => {
          if (event === 'info') {
            callback({ uri: `http://example.com/${fileName}` });
          }
        }),
      };
      telegram.getFileStream = jest.fn(() => fileStream);
      fs.createWriteStream.mockReturnValue('writeStream');
      pump.mockImplementation((source, destination, callback) => callback());

      return expect(telegram.downloadFile(fileId, downloadDir)).resolves.toBe(filePath);
    });

    it('should reject with error if file download fails', () => {
      const fileId = '123';
      const downloadDir = '/downloads';
      const error = new Error('Download failed');
      const fileStream = {
        on: jest.fn((event, callback) => {
          if (event === 'error') {
            callback(error);
          }
        }),
      };
      telegram.getFileStream = jest.fn(() => fileStream);

      return expect(telegram.downloadFile(fileId, downloadDir)).rejects.toThrow(error);
    });
  });
});
