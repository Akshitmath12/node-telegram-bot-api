// ********RoostGPT********
/*
Test generated by RoostGPT for test NodeTest using AI Type Open AI and AI Model gpt-4

ROOST_METHOD_HASH=7a98b88912
ROOST_METHOD_SIG_HASH=5f21bf8e5f


*/

// ********RoostGPT********
const Telegram = require('./telegram');
const errors = require('./errors');
const request = require('request-promise-native');

describe('Telegram Bot _request method', () => {
  let telegram;
  beforeEach(() => {
    telegram = new Telegram('test_token');
  });

  test('should reject when token is not provided', () => {
    telegram.token = null;
    return expect(telegram._request('test_path')).rejects.toBeInstanceOf(errors.FatalError);
  });

  test('should send POST request with correct options', () => {
    const options = {
      form: {
        markup: 'test_markup',
        entities: 'test_entities',
        parameters: 'test_parameters',
      },
      qs: {
        markup: 'test_markup',
        parameters: 'test_parameters',
      },
    };
    const response = {
      body: JSON.stringify({
        ok: true,
        result: 'test_result',
      }),
    };
    request.mockResolvedValue(response);
    return telegram._request('test_path', options).then((result) => {
      expect(request).toHaveBeenCalledWith({
        ...options,
        method: 'POST',
        url: telegram._buildURL('test_path'),
        simple: false,
        resolveWithFullResponse: true,
        forever: true,
      });
      expect(result).toBe('test_result');
    });
  });

  test('should throw ParseError when response body cannot be parsed', () => {
    const response = {
      body: 'invalid_json',
    };
    request.mockResolvedValue(response);
    return expect(telegram._request('test_path')).rejects.toBeInstanceOf(errors.ParseError);
  });

  test('should throw TelegramError when response body contains error', () => {
    const response = {
      body: JSON.stringify({
        ok: false,
        error_code: 'test_error_code',
        description: 'test_description',
      }),
    };
    request.mockResolvedValue(response);
    return expect(telegram._request('test_path')).rejects.toBeInstanceOf(errors.TelegramError);
  });

  test('should throw FatalError when unexpected error occurs', () => {
    request.mockRejectedValue(new Error('test_error'));
    return expect(telegram._request('test_path')).rejects.toBeInstanceOf(errors.FatalError);
  });
});
