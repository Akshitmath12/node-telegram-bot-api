// ********RoostGPT********
/*
Test generated by RoostGPT for test NodeTest using AI Type Open AI and AI Model gpt-4

ROOST_METHOD_HASH=e79c2f8368
ROOST_METHOD_SIG_HASH=085d25d8b8


*/

// ********RoostGPT********
const TelegramBot = require('../src/telegram');
const TelegramBotPolling = require('../src/telegramBotPolling');
const errors = require('../src/errors');

describe('TelegramBot startPolling method', () => {
  let telegramBot;
  let mockTelegramBotPolling;

  beforeEach(() => {
    telegramBot = new TelegramBot();
    mockTelegramBotPolling = new TelegramBotPolling();
    jest.spyOn(telegramBot, 'hasOpenWebHook').mockReturnValue(false);
    jest.spyOn(TelegramBotPolling, 'start').mockReturnValue(Promise.resolve());
  });

  test('should reject with FatalError if hasOpenWebHook is true', () => {
    telegramBot.hasOpenWebHook.mockReturnValue(true);
    return expect(telegramBot.startPolling()).rejects.toThrow(errors.FatalError);
  });

  test('should start polling if hasOpenWebHook is false', () => {
    return telegramBot.startPolling().then(() => {
      expect(TelegramBotPolling.start).toHaveBeenCalled();
    });
  });

  test('should create new instance of TelegramBotPolling if _polling is undefined', () => {
    jest.spyOn(telegramBot, '_polling').mockReturnValue(undefined);
    jest.spyOn(TelegramBotPolling, 'constructor').mockReturnValue(mockTelegramBotPolling);
    
    return telegramBot.startPolling().then(() => {
      expect(TelegramBotPolling.constructor).toHaveBeenCalled();
      expect(telegramBot._polling).toBe(mockTelegramBotPolling);
    });
  });
});
