// ********RoostGPT********
/*
Test generated by RoostGPT for test NodeTest using AI Type Open AI and AI Model gpt-4

ROOST_METHOD_HASH=913dda88f7
ROOST_METHOD_SIG_HASH=1d145e5d8a


*/

// ********RoostGPT********
const Telegram = require('./telegram');
const errors = require('./errors');
const TelegramBotWebHook = require('./telegramBotWebHook');

describe('Telegram', () => {
  let telegram;

  beforeEach(() => {
    telegram = new Telegram();
  });

  afterEach(() => {
    jest.clearAllMocks();
  });

  test('openWebHook should reject if isPolling returns true', () => {
    telegram.isPolling = jest.fn().mockReturnValue(true);

    return expect(telegram.openWebHook()).rejects.toThrow(errors.FatalError);
  });

  test('openWebHook should create new TelegramBotWebHook if _webHook is not defined', () => {
    telegram.isPolling = jest.fn().mockReturnValue(false);
    telegram._webHook = null;

    const mockWebHook = { open: jest.fn() };
    jest.spyOn(global, 'TelegramBotWebHook').mockImplementation(() => mockWebHook);

    return telegram.openWebHook().then(() => {
      expect(telegram._webHook).toBe(mockWebHook);
      expect(TelegramBotWebHook).toHaveBeenCalledWith(telegram);
      expect(mockWebHook.open).toHaveBeenCalled();
    });
  });

  test('openWebHook should not create new TelegramBotWebHook if _webHook is already defined', () => {
    telegram.isPolling = jest.fn().mockReturnValue(false);
    telegram._webHook = { open: jest.fn() };

    const mockWebHook = { open: jest.fn() };
    jest.spyOn(global, 'TelegramBotWebHook').mockImplementation(() => mockWebHook);

    return telegram.openWebHook().then(() => {
      expect(telegram._webHook).not.toBe(mockWebHook);
      expect(TelegramBotWebHook).not.toHaveBeenCalled();
      expect(telegram._webHook.open).toHaveBeenCalled();
    });
  });
});
