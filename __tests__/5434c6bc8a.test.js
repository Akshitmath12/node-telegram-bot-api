// ********RoostGPT********
/*
Test generated by RoostGPT for test NodeTest using AI Type Open AI and AI Model gpt-4

ROOST_METHOD_HASH=8c03564528
ROOST_METHOD_SIG_HASH=5434c6bc8a


*/

// ********RoostGPT********
const Telegram = require('./telegram');

describe('sendVoice Method Test Suite', () => {
  let telegram;
  let chatId;
  let voice;
  let options;
  let fileOptions;

  beforeAll(() => {
    telegram = new Telegram();
    chatId = '123456';
    voice = 'voice message';
    options = {};
    fileOptions = {};
  });

  test('should send voice correctly', () => {
    const _formatSendDataMock = jest.fn().mockReturnValue([{}, 'voice message']);
    const _requestMock = jest.fn().mockReturnValue(Promise.resolve('Voice sent'));

    telegram._formatSendData = _formatSendDataMock;
    telegram._request = _requestMock;

    return telegram.sendVoice(chatId, voice, options, fileOptions)
      .then(response => {
        expect(response).toEqual('Voice sent');
        expect(_formatSendDataMock).toHaveBeenCalledWith('voice', voice, fileOptions);
        expect(_requestMock).toHaveBeenCalledWith('sendVoice', { qs: { chat_id: chatId, voice: 'voice message' }, formData: {} });
      });
  });

  test('should handle error when send voice', () => {
    const error = new Error('Failed to send voice');
    const _formatSendDataMock = jest.fn().mockReturnValue([{}, 'voice message']);
    const _requestMock = jest.fn().mockReturnValue(Promise.reject(error));

    telegram._formatSendData = _formatSendDataMock;
    telegram._request = _requestMock;

    return telegram.sendVoice(chatId, voice, options, fileOptions)
      .catch(err => {
        expect(err).toEqual(error);
        expect(_formatSendDataMock).toHaveBeenCalledWith('voice', voice, fileOptions);
        expect(_requestMock).toHaveBeenCalledWith('sendVoice', { qs: { chat_id: chatId, voice: 'voice message' }, formData: {} });
      });
  });
});
